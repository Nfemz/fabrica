# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Hytale plugin template for building Java-based server plugins. It uses Gradle with automatic Hytale server JAR detection and IDE run configuration generation.

**Early Access Warning**: Hytale is in Early Access. APIs are subject to breaking changes.

## Build Commands

```bash
./gradlew build              # Standard build
./gradlew shadowJar          # Create distributable JAR with dependencies
./gradlew test               # Run tests
./gradlew updatePluginManifest  # Sync manifest.json with gradle.properties
./gradlew generateVSCodeLaunch  # Generate .vscode/launch.json
```

Output JAR: `build/libs/<project-name>-<version>.jar`

## Configuration Files

- **gradle.properties**: Version, maven group, Java version, patchline (release/pre-release), hytale_home path
- **settings.gradle**: Project name (rootProject.name)
- **src/main/resources/manifest.json**: Plugin metadata (Name, Version, Main class, etc.)

**Critical**: The `Main` property in manifest.json must exactly match the plugin entry-point class (e.g., `org.example.plugin.ExamplePlugin`).

## Development Workflow

1. Run `HytaleServer` configuration in IntelliJ (auto-generated by Gradle)
2. First run: authenticate with `auth login device` then `auth persistence Encrypted` in server console
3. Connect Hytale client to `127.0.0.1`
4. Test with `/test` command

## Key Dependencies

- Java 25 SDK required
- Hytale server JAR auto-resolved from local Hytale installation
- Hytale home auto-detected or set via `hytale_home` property in gradle.properties

---

## Hytale Plugin API Reference

### Plugin Lifecycle

Plugins extend `JavaPlugin` (`com.hypixel.hytale.server.core.plugin.JavaPlugin`):

```java
public class MyPlugin extends JavaPlugin {
    private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();

    public MyPlugin(@Nonnull JavaPluginInit init) {
        super(init);
    }

    @Override
    protected void preLoad() {
        // Async config loading before initialization
    }

    @Override
    protected void setup() {
        // Register commands, events, assets
    }

    @Override
    protected void start() {
        // Post-setup logic, all plugins initialized
    }

    @Override
    protected void shutdown() {
        // Cleanup before registry finalization
    }
}
```

### Available Registries

| Registry | Access Method | Purpose |
|----------|---------------|---------|
| CommandRegistry | `getCommandRegistry()` | Player/console commands |
| EventRegistry | `getEventRegistry()` | Game event listeners |
| TaskRegistry | `getTaskRegistry()` | Async/scheduled tasks |
| EntityRegistry | `getEntityRegistry()` | Custom entity types |
| BlockStateRegistry | `getBlockStateRegistry()` | Custom block states |
| AssetRegistry | `getAssetRegistry()` | Textures, models, sounds |
| EntityStoreRegistry | `getEntityStoreRegistry()` | Entity ECS components |
| ChunkStoreRegistry | `getChunkStoreRegistry()` | Chunk ECS components |
| ClientFeatureRegistry | `getClientFeatureRegistry()` | Client behavior features |

### Utility Methods

- `getLogger()` → `HytaleLogger` for logging
- `getDataDirectory()` → `Path` for plugin config/data folder
- `getManifest()` → `PluginManifest` for metadata access
- `withConfig()` → Configuration file registration

---

## Commands

### Basic Command (CommandBase)

```java
public class MyCommand extends CommandBase {
    public MyCommand() {
        super("commandname", "Description");
        this.setPermissionGroup(GameMode.Adventure); // Allows all players
    }

    @Override
    protected void executeSync(@Nonnull CommandContext ctx) {
        ctx.sendMessage(Message.raw("Response text"));
    }
}
```

### Player Command with ECS Access (AbstractPlayerCommand)

Use when accessing player components (thread-safe ECS access):

```java
public class WhereAmICommand extends AbstractPlayerCommand {
    public WhereAmICommand() {
        super("whereami", "Shows your location");
        this.setPermissionGroup(GameMode.Adventure);
    }

    @Override
    protected void execute(@Nonnull CommandContext ctx,
            @Nonnull Store<EntityStore> store, @Nonnull Ref<EntityStore> ref,
            @Nonnull PlayerRef playerRef, @Nonnull World world) {
        Player player = store.getComponent(ref, Player.getComponentType());
        TransformComponent transform = store.getComponent(ref, TransformComponent.getComponentType());
        player.sendMessage(Message.raw("Position: " + transform.getPosition()));
    }
}
```

### Command Arguments

```java
// In constructor:
RequiredArg<String> messageArg = this.withRequiredArg("message", "The message", ArgTypes.STRING);
RequiredArg<Integer> countArg = this.withRequiredArg("count", "Number", ArgTypes.INTEGER);

// In execute:
String message = messageArg.get(ctx);
int count = countArg.get(ctx);
```

**Argument Types**: `ArgTypes.STRING`, `INTEGER`, `BOOLEAN`, `FLOAT`, `DOUBLE`, `UUID`

### Registration

```java
@Override
protected void setup() {
    this.getCommandRegistry().registerCommand(new MyCommand());
}
```

---

## Events

### Standard Event Registration

```java
// Basic registration
getEventRegistry().register(PlayerJoinEvent.class, this::onPlayerJoin);

// With priority (FIRST, EARLY, NORMAL, LATE, LAST)
getEventRegistry().register(EventPriority.EARLY, SomeEvent.class, this::handleEarly);

// Global registration (all instances)
getEventRegistry().registerGlobal(PlayerReadyEvent.class, this::onPlayerReady);

// Keyed events (specific context)
getEventRegistry().register(WorldEvent.class, "world_name", this::onWorldEvent);
```

### Event Handler Example

```java
public void onPlayerReady(PlayerReadyEvent event) {
    Player player = event.getPlayer();
    player.sendMessage(Message.raw("Welcome " + player.getDisplayName()));
}
```

### Common Events

- **Server**: `BootEvent`, `ShutdownEvent`, `PluginSetupEvent`
- **World**: `AddWorldEvent`, `RemoveWorldEvent`, `AllWorldsLoadedEvent`
- **Player**: `PlayerConnectEvent`, `PlayerDisconnectEvent`, `PlayerChatEvent`, `PlayerReadyEvent`
- **Block**: `PlaceBlockEvent`, `BreakBlockEvent`, `DamageBlockEvent` (all implement `ICancellable`)
- **Entity**: `EntityRemoveEvent`, `EntitySpawnEvent`

### Cancellable Events

```java
public void onBlockBreak(BreakBlockEvent event) {
    if (someCondition) {
        event.setCancelled(true);
    }
}
```

### ECS Entity Events (EntityEventSystem)

For events in the Entity Component System:

```java
class CancelCraftSystem extends EntityEventSystem<EntityStore, CraftRecipeEvent.Pre> {
    public CancelCraftSystem() {
        super(CraftRecipeEvent.Pre.class);
    }

    @Override
    public void handle(int index, @Nonnull ArchetypeChunk<EntityStore> chunk,
            @Nonnull Store<EntityStore> store, @Nonnull CommandBuffer<EntityStore> buffer,
            @Nonnull CraftRecipeEvent.Pre event) {
        if (shouldCancel(event.getCraftedRecipe())) {
            event.setCancelled(true);
        }
    }

    @Override
    public Query<EntityStore> getQuery() {
        return Archetype.empty();
    }
}

// Registration in setup():
this.getEntityStoreRegistry().registerSystem(new CancelCraftSystem());
```

---

## Task Scheduling & Async

### TaskRegistry

```java
TaskRegistry tasks = getTaskRegistry();

// Register CompletableFuture (auto-cancelled on plugin disable)
CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
    // Background work
});
tasks.registerTask(future);
```

### Scheduled Tasks

```java
// Using HytaleServer.SCHEDULED_EXECUTOR (single-threaded)
ScheduledFuture<?> scheduled = HytaleServer.SCHEDULED_EXECUTOR.scheduleAtFixedRate(
    () -> saveData(),
    5, 5, TimeUnit.MINUTES
);
getTaskRegistry().registerTask((ScheduledFuture<Void>) scheduled);
```

### World Thread Execution

World state must only be modified on the world thread:

```java
world.execute(() -> {
    // Safe to modify blocks, entities here
});

// Async load then apply on world thread
CompletableFuture.supplyAsync(() -> loadData())
    .thenAcceptAsync(data -> applyData(data), world);
```

**Never** block the world thread with `.join()` or `Thread.sleep()`.

---

## Entity Spawning

Requires understanding of the Entity Component System (ECS).

```java
world.execute(() -> {
    Store<EntityStore> store = world.getEntityStore().getStore();
    Holder<EntityStore> holder = EntityStore.REGISTRY.newHolder();

    // Model
    ModelAsset modelAsset = ModelAsset.getAssetMap().getAsset("Minecart");
    Model model = Model.createScaledModel(modelAsset, 1.0f);

    // Required components
    holder.ensureComponent(UUIDComponent.getComponentType());
    // Add TransformComponent, ModelComponent, BoundingBox, NetworkId, etc.

    store.addEntity(holder, AddReason.SPAWN);
});
```

---

## Permissions

### Permission Checking

```java
PermissionsModule permissions = PermissionsModule.get();
boolean canTeleport = permissions.hasPermission(playerUuid, "hytale.command.teleport");
```

### Built-in Permission Groups

- **OP**: Has `*` wildcard (all permissions)
- **Default**: Assigned to all players

### GameMode-Based Permissions

```java
this.setPermissionGroup(GameMode.Adventure); // All players
this.setPermissionGroup(GameMode.Creative);  // Creative mode only
this.requirePermission(HytalePermissions.fromCommand("mycommand.use"));
```

---

## Asset Bundling (Packs)

### Directory Structure

```
src/main/resources/
├── Common/
│   ├── BlockTextures/     # 16x16 or 32x32 PNG textures
│   ├── Icons/ItemsGenerated/
│   └── Models/
└── Server/
    ├── Block/
    ├── Item/
    │   ├── Items/         # Item JSON definitions
    │   ├── Category/
    │   └── Recipes/       # Crafting recipes
    └── Languages/
        └── en-US/
            └── server.lang
```

Set `includes_pack=true` in gradle.properties to enable.

### Block Definition Example

`Server/Item/Items/Example_Block.json`:
```json
{
  "TranslationProperties": { "Name": "server.Example_Block.name" },
  "MaxStack": 100,
  "Icon": "Icons/ItemsGenerated/Example_Block.png",
  "Categories": ["Blocks.Rocks"],
  "BlockType": {
    "Material": "Solid",
    "DrawType": "Cube",
    "Group": "Stone",
    "Textures": [{"All": "BlockTextures/Example_Block.png"}],
    "BlockSoundSetId": "Stone",
    "ParticleColor": "#aeae8c"
  }
}
```

### Per-Side Textures

```json
"Textures": [{
  "Top": "BlockTextures/Block_Top.png",
  "Bottom": "BlockTextures/Block_Bottom.png",
  "Sides": "BlockTextures/Block_Sides.png"
}]
```

### Translation File

`Server/Languages/en-US/server.lang`:
```
Example_Block.name = Example Block
```

---

## Logging

```java
private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();

LOGGER.atInfo().log("Information message");
LOGGER.atWarning().log("Warning message");
LOGGER.atSevere().withCause(exception).log("Error occurred");
```

---

## External Documentation

- [Hytale Modding Documentation (Britakee Studios)](https://britakee-studios.gitbook.io/hytale-modding-documentation)
- [HytaleDocs Community Wiki](https://hytale-docs.com/docs/modding/plugins/overview)
- [Hytale Server Docs (Unofficial)](https://hytale-docs.pages.dev/modding/plugins/plugin-system/)
- [HytaleModding.dev Guides](https://hytalemodding.dev/en/docs/guides/plugin/creating-events)
